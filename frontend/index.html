<html>
<h1>You should be doing: <span></span></h1>
<input
    placeholder="Enter threads separated by commas for priority. Threads not mentioned shall be ordered in alphabetical order.">
<h2>All thread states</h2>
<div></div>
<script>
    const main = () => {
        const thread_order = load_thread_order();
        const thread_states = {};
        renderer = make_renderer(thread_states, thread_order);
        handle_thread_order_changes(thread_order, renderer);
        handle_thread_state_updates(thread_states, renderer);
        renderer.render(); // Render the first time
    }

    const load_thread_order = () => {
        let thread_order = [];
        const thread_order_json = localStorage.getItem("thread_order")
        try {
            thread_order = JSON.parse(thread_order_json) || [];
        } catch (ex) {
            console.log(`oh no, stored thread order was ${thread_order_json}`)
        }
        const inpu = document.querySelector("input");
        inpu.value = thread_order.join(",")
        return thread_order;
    }

    const make_renderer = (thread_states, thread_order) => {
        return {
            render: () => {
                const div = document.querySelector("div");
                const span = document.querySelector("span");
                div.innerHTML = "";
                const thread_state_entries = Object.entries(thread_states);
                thread_state_entries.sort((thread_entry_1, thread_entry_2) => {
                    const item1Order = thread_order.indexOf(thread_entry_1[0]);
                    const item2Order = thread_order.indexOf(thread_entry_2[0]);
                    if (item1Order != -1 && item2Order != -1) {
                        return item1Order < item2Order ? -1 : 1;
                    } else if (item1Order == -1 && item2Order == -1) {
                        return thread_entry_1[0] < thread_entry_2[0] ? -1 : 1
                    } else if (item1Order == -1) {
                        return 1;
                    } else {
                        return -1;
                    }
                })
                let first_you_entry = undefined;
                let first_you_entry_state;
                let prev_entry = undefined;
                thread_state_entries.forEach(entry => {
                    let closure_prev_entry = prev_entry;
                    if ((entry[1].state == "YOU_DOING" || entry[1].state == "YOU_COULD_BE_DOING") && first_you_entry == undefined) {
                        first_you_entry = entry[0];
                        first_you_entry_state = entry[1].state;
                    }
                    const up_btn = document.createElement("button");
                    up_btn.innerText = "^";
                    up_btn.addEventListener("click", () => {
                        const old_idx = thread_order.indexOf(entry[0])
                        if (old_idx != -1) {
                            thread_order.splice(old_idx, 1);
                        }
                        if (closure_prev_entry != undefined) {
                            new_pos = thread_order.indexOf(closure_prev_entry);
                        } else {
                            new_pos = thread_order.length;
                        }
                        thread_order.splice(new_pos, 0, entry[0]);
                        localStorage.setItem("thread_order", JSON.stringify(thread_order));
                        const inpu = document.querySelector("input");
                        inpu.value = thread_order.join(",")
                        renderer.render();
                    })
                    const p = document.createElement("p");
                    p.append(up_btn);
                    const sp = document.createElement("span");
                    sp.innerText = `${entry[0]} : ${JSON.stringify(entry[1])}`;
                    p.appendChild(sp);
                    div.appendChild(p);
                    prev_entry = entry[0];
                })
                if (first_you_entry_state == "YOU_COULD_BE_DOING") {
                    document.body.style.background = "orange";
                } else if (first_you_entry_state == undefined) {
                    document.body.style.background = "white";
                } else {
                    document.body.style.background = "lightgreen";
                }
                span.innerText = first_you_entry || "nothing";
            }
        }
    }

    const handle_thread_order_changes = (thread_order, renderer) => {
        const inpu = document.querySelector("input");
        inpu.addEventListener("keyup", () => {
            thread_order.splice(0, thread_order.length);
            const split_thread_names = inpu.value.split(",")
            thread_order.push(...split_thread_names)
            localStorage.setItem("thread_order", JSON.stringify(thread_order));
            renderer.render();
        })
    }

    const handle_thread_state_updates = (thread_states, renderer) => {
        const websocket = new WebSocket(`wss://${window.location.host}`);
        websocket.addEventListener("message", (message) => {
            const statusUpdate = JSON.parse(message.data);
            thread_states[statusUpdate.thread_id] = statusUpdate;
            renderer.render();
        })
        websocket.addEventListener("close", () => {
            setTimeout(handle_thread_state_updates, 500);
        })
    }

    main();

</script>

</html>